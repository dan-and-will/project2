#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import json
import sys
import socket
import select
import threading

from forwarding_table import ForwardingTable

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

class Port:

    def __init__(self, sock):
        self.pid = sock.fileno()
        self.socket = sock
        self.isEnabled = True
        self.isRoot = False
        self.isDesignated = False

def compare_bpdus(bpdu1, bpdu2):
    if bpdu1['root'] < bpdu2['root']:
        return bpdu1
    elif bpdu1['root'] == bpdu2['root'] and bpdu1['cost'] < bpdu2['cost']:
        return bpdu1
    elif bpdu1['root'] == bpdu2['root'] and bpdu1['cost'] == bpdu2['cost'] and bpdu1['id'] < bpdu2['id']:
        return bpdu1
    return bpdu2

class Bridge:

    def __init__(self, bid, LANs):
        self.ftable = ForwardingTable()
        self.id = bid
        self.LANs = LAN
        self.ports = {}
        self.closed_ports = set()
        self.root_port = None
        self.bpdu = {'root': bid, 'cost': 0, 'id': bid}

        # creates sockets and connects to them
        for i in range(len(LAN)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(LAN[i]))
            self.ports[s.fileno()] = Port(s)

        print "Bridge " + bid + " starting up\n"

    def close_port(self, pid):
        print 'Disabled port: {id}/{pid}'.format(id=self.id, pid=pid)
        self.closed_ports.add(pid)

    def open_port(self, pid):
        self.closed_ports.discard(pid)

    def get_open_ports(self):
        return [self.ports[pid] for pid in self.ports if pid not in self.closed_ports]

    def use_bpdu(self, bpdu, pid):
        print 'New root: {id}/{root}'.format(id=self.id, root=bpdu['root'])
        print 'Root port: {id}/{port_id}'.format(id=self.id, port_id=pid)
        self.root_port = self.ports[pid]
        self.bpdu = bpdu
        self.bpdu['cost'] += 1

    def make_bpdu_packet(self):
        """ {"source":"02a1", "dest":"ffff", "type": "bpdu",
        "message":{"id":"92b4", "root":"02a1", "cost":3}}
        """
        bpdu = {'id': self.id, 'root': self.root, 'cost': self.root_cost}
        bpdu_packet = {'source': self.id, 'dest': 'ffff', 'type': 'bpdu', 'message': bpdu}
        return json.dumps(bpdu_packet)

    def process_bpdu(self, msg, pid):
        root_bpdu = compare_bpdus(self.bpdu, msg)
        self.use_bpdu(root_bpdu, pid)

    def send_message(self, msg, ports=None):
        if ports is None:
            ports = self.ports.itervalues()
        _, ready, _ = select.select({}, [p.socket for p in ports], [], 1)
        for s in ready:
            s.send(msg)

    def forward_message(self, msg):
        dest_mac = msg['dest']
        port_id = self.ftable.read_row(dest_mac)
        if port_id < 0:
            ports = self.get_open_ports()
        else:
            ports = [self.ports[port_id]]
        msg = json.dumps(msg)
        for p in ports:
            self.send_message(msg, ports=ports)

    def process_message(self, data, pid):
        msg = json.loads(data)
        self.ftable.write_row(msg['source'], pid)
        if msg['type'] == 'bpdu':
            self.process_bpdu(msg['message'], pid)
        if msg['type'] == 'data':
            self.forward_message(msg)

    def send_bpdus(self):
        self.send_message(self.make_bpdu_packet())
        threading.Timer(0.5, self.send_bpdus).start()

    def run(self):
        self.send_bpdus()
        while True:
            # Calls select with all the sockets; change the timeout value (1)
            ready, _, _ = select.select([p.socket for p in self.ports.itervalues()], [], [], 1)

            # Reads from each of the ready sockets
            for s in ready:
                data = s.recv(1500)
                self.process_message(data, s.fileno())

if __name__ == '__main__':
    bid = sys.argv[1]
    LAN = sys.argv[2:]
    bridge = Bridge(bid, LAN)
    bridge.run()
