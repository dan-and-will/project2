#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
from datetime import datetime, timedelta
import json
import sys
import socket
import select
import threading

from bpdu import Bpdu
from forwarding_table import ForwardingTable

def pad(name):
    """pads the name with null bytes at the end
    """
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

class Bridge:

    def __init__(self, bid, LANs):
        """sets up bridge with command line params and default values
        """
        self.ftable = ForwardingTable()
        self.id = bid
        self.LANs = LAN
        self.ports = {}
        self.closed_ports = set()
        self.root_port = None
        self.bpdu = Bpdu(bid, 0, bid)

        # creates sockets and connects to them
        for i in range(len(LAN)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(LAN[i]))
            self.ports[s.fileno()] = s

        print "Bridge " + bid + " starting up\n"

    def disable_port(self, pid):
        """disables port
        """
        print 'Disabled port: {id}/{pid}'.format(id=self.id, pid=pid)
        self.closed_ports.add(pid)

    def enable_port(self, pid):
        """enables port
        """
        self.closed_ports.discard(pid)

    def get_open_ports(self, exclude_pid=None):
        """returns all enabled ports
        exclude_pid is optional and is used to exclude the port that recieved the message
        """
        return [self.ports[pid] for pid in self.ports if pid not in self.closed_ports and pid != exclude_pid]

    def use_bpdu(self, bpdu, pid):
        """configures bridge based on better BPDU
        """
        print 'New root: {id}/{root}'.format(id=self.id, root=bpdu.root)
        print 'Root port: {id}/{port_id}'.format(id=self.id, port_id=pid)
        self.root_port = self.ports[pid]
        self.bpdu = Bpdu(bpdu.root, bpdu.cost + 1, self.id)

    def process_bpdu(self, packet, pid):
        """compares incoming BPDU messages to the current bridge configuration
        updates the bridge if necessary
        """
        other_bpdu = Bpdu(packet['message']['root'],
                          packet['message']['cost'],
                          packet['source']
                          )
        if other_bpdu < self.bpdu:
            self.use_bpdu(other_bpdu, pid)

    def send_message(self, msg, ports):
        """generic method to send a message on a list of ports
        """
        _, ready, _ = select.select({}, ports, [], 1)
        ####TODO: for debugging. DELETE
        print 'Sending {msg} on ports: {ready}/{ports}'.format(msg=msg,
                                                               ready=[s.fileno() for s in ready],
                                                               ports=self.ports.keys()
                                                               )
        for s in ready:
            s.send(msg)

    def forward_message(self, msg, rescv_pid):
        """handles sending message to destination
        """
        self.ftable.write_row(msg['source'], pid)
        port_id = self.ftable.read_row(msg['dest'])
        if port_id < 0:
            ports = self.get_open_ports()
        else:
            ports = [self.ports[port_id]]
        msg = json.dumps(msg)
        self.send_message(msg, ports)

    def process_message(self, data, pid):
        """records new hosts on forwarding table and delegates further
        processing to other methods
        """
        msg = json.loads(data)
        if msg['type'] == 'bpdu':
            self.process_bpdu(msg, pid)
        if msg['type'] == 'data'and not pid in self.closed_ports:
            self.forward_message(msg, pid)

    def send_bpdus(self):
        """recursively sends BPDUs on a seperate thread every 500ms
        """
        self.send_message(str(self.bpdu), self.ports.values())
        #threading.Timer(0.5, self.send_bpdus).start()

    def run(self):
        """constantly check ports for incomming messages
        """
        bpdu_wait = timedelta(seconds=0.5)
        self.send_bpdus()
        last_sent = datetime.now()
        while True:
            if datetime.now() - last_sent > bpdu_wait:
                self.send_bpdus()
                last_sent = datetime.now()

            # Calls select with all the sockets; change the timeout value (1)
            ready, _, _ = select.select(self.ports.values(), [], [], 1)

            # Reads from each of the ready sockets
            for s in ready:
                data = s.recv(1500)
                self.process_message(data, s.fileno())

if __name__ == '__main__':
    """sets up and runs bridge
    """
    bid = sys.argv[1]
    LAN = sys.argv[2:]
    bridge = Bridge(bid, LAN)
    bridge.run()
