#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
from datetime import datetime, timedelta
import json
import sys
import socket
import select
import threading

from bpdu import Bpdu
from forwarding_table import ForwardingTable

def pad(name):
    """pads the name with null bytes at the end
    """
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

BPDU_SEND_INTERVAL = timedelta(seconds=0.5)

class Bridge:

    def __init__(self, bid, lans):
        """sets up bridge with command line params and default values
        """
        self.ftable = ForwardingTable()
        self.id = bid
        self.lans = lans
        self.ports = {}
        self.closed_ports = set()
        self.root_pid = None
        self.bpdu = Bpdu(bid, 0, bid)
        self.default_bpdu = Bpdu(bid, 0, bid)
        self.last_bpdu_time = datetime.utcfromtimestamp(0)
        # creates sockets and connects to them
        for lan in lans:
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(lan))
            self.ports[s.fileno()] = s
        print "Bridge " + bid + " starting up\n"

    def disable_port(self, pid):
        """disables port
        """
        if pid != self.root_pid:
            print 'Disabled port: {id}/{pid}'.format(id=self.id, pid=pid)
            self.closed_ports.add(pid)

    def enable_port(self, pid):
        """enables port
        """
        print 'Enabled port: {id}/{pid}'.format(id=self.id, pid=pid)
        self.closed_ports.discard(pid)

    def get_open_ports(self, exclude_pid=None):
        """returns all enabled ports
        exclude_pid is optional and is used to exclude the port that recieved the message
        """
        return [self.ports[pid] for pid in self.ports if pid not in self.closed_ports and pid != exclude_pid]

    def use_bpdu(self, bpdu, pid):
        """configures bridge based on better BPDU
        """
        print 'New root: {id}/{root}, cost: {c}'.format(id=self.id, root=bpdu.root, c=bpdu.cost+1)
        print 'Root port: {id}/{port_id}'.format(id=self.id, port_id=pid)
        self.root_pid = pid
        self.bpdu = Bpdu(bpdu.root, bpdu.cost + 1, self.id)
        self.send_bpdu(send_now=True)

    def process_bpdu(self, packet, pid):
        """compares incoming BPDU messages to the current bridge configuration
        updates the bridge if necessary
        """
        if packet['source'] == self.id and packet['message']['id'] > pid:
            self.disable_port(pid)
            return
        other_bpdu = Bpdu(packet['message']['root'],
                          packet['message']['cost'],
                          packet['source']
                          )
        if other_bpdu < self.bpdu:
            self.use_bpdu(other_bpdu, pid)
            self.enable_port(pid)
        elif other_bpdu.root == self.bpdu.root and other_bpdu.cost <= self.bpdu.cost and other_bpdu.bid < self.bpdu.bid:
            self.disable_port(pid)
        else:
            print "Designated port: {bid} / {pid}".format(bid=self.id, pid=pid)
            self.enable_port(pid)

    def send_message(self, msg, ports):
        """generic method to send a message on a list of ports
        """
        _, ready, _ = select.select({}, ports, [], 1)
        ####TODO: for debugging. DELETE
        print 'Sending msg id {msg} on ports: {ready}/{ports}'.format(msg=msg['message']['id'],
                                                               ready=[s.fileno() for s in ready],
                                                               ports=[s.fileno() for s in ports]
                                                               )
        for s in ready:
            s.send(msg)

    def forward_message(self, msg, recv_pid):
        """handles sending message to destination
        """
        if recv_pid in self.closed_ports:
            return
        print 'Received message {id} on port {pid} from {source} to {dest}'.format(id=msg['mesage']['id'],
                                                                                   pid=recv_pid,
                                                                                   source=msg['source'],
                                                                                   dest=msg['dest']
                                                                                   )
        self.ftable.write_row(msg['source'], recv_pid)
        dest_pid = self.ftable.read_row(msg['dest'])
        if dest_pid < 0:
            print 'Broadcasting message <id> to all ports {pts}'.format(id=msg['message']['id'])
            ports = self.get_open_ports(exclude_pid=recv_pid)
        elif dest_pid == recv_pid:
            print 'Not forwarding message {id}'.format(id=msg['message']['id'])
            return
        else:
            print 'Forwarding message {id} to port {pid}'.format(id=msg['message']['id'],
                                                                 pid=recv_pid
                                                                 )
            ports = [self.ports[dest_pid]]
        msg = json.dumps(msg)
        self.send_message(msg, ports)

    def process_message(self, data, pid):
        """records new hosts on forwarding table and delegates further
        processing to other methods
        """
        msg = json.loads(data)
        if msg['type'] == 'bpdu':
            self.process_bpdu(msg, pid)
        if msg['type'] == 'data':
            self.forward_message(msg, pid)

    def send_bpdu(self, send_now=False):
        """handles deciding whether it's time to send a BPDU and what BPDU to send
        """
        if datetime.now() - self.last_bpdu_time > BPDU_SEND_INTERVAL or send_now:
            if self.bpdu.is_timedout():
                self.bpdu = self.default_bpdu
            self.last_bpdu_time = datetime.now()
            for pid, port in self.ports.iteritems():
                port.send(self.bpdu.create(pid))

    def run(self):
        """constantly check ports for incomming messages
        """
        while True:
            self.send_bpdu()

            # Calls select with all the sockets; change the timeout value (1)
            ready, _, _ = select.select(self.ports.values(), [], [], 1)

            # Reads from each of the ready sockets
            for s in ready:
                data = s.recv(1500)
                self.process_message(data, s.fileno())

if __name__ == '__main__':
    """sets up and runs bridge
    """
    bid = sys.argv[1]
    lans = sys.argv[2:]
    bridge = Bridge(bid, lans)
    bridge.run()
